# Модульное (Unit) тестирование и Data-Driven тесты

## Содержание
- [Пирамида тестирования](#пирамида-тестирования)
- [Инструменты тестирования](#инструменты-тестирования)
- [Jest: Фреймворк для тестирования](#jest-фреймворк-для-тестирования)
- [Паттерн Arrange-Act-Assert (AAA)](#паттерн-arrange-act-assert-aaa)
- [Параметризация тестов (Data-Driven)](#параметризация-тестов-data-driven)
- [Работа с ошибками](#работа-с-ошибками)
- [Покрытие кода тестами](#покрытие-кода-тестами)
- [Установка и настройка Jest](#установка-и-настройка-jest)
- [Полезные ресурсы](#полезные-ресурсы)

## Пирамида тестирования
Концепция, которая помогает классифицировать тесты по уровням. Чем ниже уровень, тем тесты быстрее, дешевле и их должно быть больше.

### Unit-тестирование
- **Цель**: Проверка отдельных модулей или функций в изоляции от остальной системы.
- **Особенности**: Многочисленные, быстрые, не имеют внешних зависимостей (базы данных, API). Используют фиктивные объекты (моки, стабы).
- **Тип**: White Box (требует знания внутренней структуры кода).

### Интеграционное/компонентное тестирование
- **Цель**: Проверка взаимодействия между несколькими модулями или компонентами системы.
- **Особенности**: Проверяет корректность передачи данных и управления между частями приложения.
- **Тип**: Black Box (не требует знания внутренней реализации).

### Сквозное (End-to-End) тестирование
- **Цель**: Проверка полного пользовательского сценария от начала до конца.
- **Особенности**: Имитирует действия реального пользователя. Тесты медленные, сложные в поддержке и хрупкие.
- **Тип**: Black Box.

## Инструменты тестирования
Тестовый фреймворк обычно состоит из нескольких частей:

- **Test Runner**: Среда для запуска тестов. Отвечает за организацию, выполнение и формирование отчетов.
- **Assertion Library**: Библиотека для проверок (утверждений). Позволяет сравнивать ожидаемый результат с фактическим и проваливать тест в случае несоответствия.
- **Mocking Library**: Библиотека для создания фиктивных объектов, которые имитируют поведение реальных зависимостей.
    - **Mock**: Настраиваемая имитация поведения объекта.
    - **Stub**: Простой объект-заглушка с жестко заданными ответами.
    - **Spy**: "Шпион", который отслеживает вызовы методов и переданные аргументы, не изменяя оригинальную логику.
- **Coverage Reporter**: Инструмент для генерации отчета о покрытии кода тестами.

**Jest** — популярный фреймворк, который включает в себя все перечисленные инструменты в одной коробке.

## Jest: Фреймворк для тестирования

### Соглашения по именованию и структуре
Jest автоматически находит и запускает тесты, если они соответствуют соглашениям:

- **Имена файлов**: `component.spec.js` или `component.test.js` (для TypeScript `.ts`)
- **Расположение**:
    1. В папке `__tests__` на верхнем уровне проекта.
    2. В папке `/specs` или `/tests`.
    3. Рядом с тестируемым файлом (например, `component.js` и `component.spec.js` в одной папке).

### Структуризация тестов: `describe`
Группирует связанные тесты в один блок для лучшей организации.

```javascript
describe('Имя компонента или модуля', () => {
  // Тесты и вложенные блоки describe
  describe('Имя тестируемой функции или фичи', () => {
    // ...
  });
});
```

### Создание тестов: `test` и `it`
Определяют отдельный тестовый случай. `it` является псевдонимом для `test`.

```javascript
describe('Мой компонент', () => {
  it('должен загружаться без ошибок', () => {
    // Логика теста
  });

  test('должен корректно работать', () => {
    // Логика теста
  });
});
```

### Проверки: `expect`
`expect` используется для создания утверждений (assertions). Он принимает значение, которое затем проверяется с помощью "матчеров" (`.toBe`, `.toEqual` и т.д.).

**Основные матчеры:**
- `.toBe(value)`: Строгое сравнение (эквивалент `===`).
- `.toEqual(object)`: Рекурсивное сравнение всех полей объекта.
- `.toBeTruthy()` / `.toBeFalsy()`: Проверка на истинность/ложность.
- `.toBeDefined()`: Проверка, что значение не `undefined`.
- `.toHaveLength(number)`: Проверка длины массива или строки.
- `.toContain(item)`: Проверка наличия элемента в массиве или подстроки в строке.
- `.toThrow(error)`: Проверка, что функция выбрасывает ошибку.
- `.not`: Инвертирует следующий за ним матчер (`expect(true).not.toBe(false)`).

Полный список: [Jest Matchers](https://jestjs.io/docs/using-matchers#common-matchers)

### Хуки: `beforeEach`, `afterEach`, `beforeAll`, `afterAll`
Функции, которые выполняются до или после тестов. Полезны для настройки и очистки тестового окружения.

- `beforeAll` / `afterAll`: Выполняются один раз перед/после всех тестов в блоке `describe`.
- `beforeEach` / `afterEach`: Выполняются перед/после каждого теста в блоке `describe`.

```javascript
describe('Component-to-test', () => {
  let objectToTest;

  beforeEach(() => {
    // Этот код будет выполняться перед каждым тестом
    objectToTest = new Component();
    objectToTest.setup();
  });
});
```

## Паттерн Arrange-Act-Assert (AAA)
Это стандартная структура для написания понятных и поддерживаемых тестов.

1.  **Arrange (Подготовка)**: Настройка начальных условий теста. Создание объектов, инициализация переменных, импорт функций.
2.  **Act (Действие)**: Выполнение основного действия, которое тестируется. Обычно это одна строка кода — вызов функции или метода.
3.  **Assert (Проверка)**: Проверка результата выполнения действия. Сравнение полученного результата с ожидаемым с помощью `expect`.

```javascript
it('должен добавить билет пользователю при покупке', () => {
  // Arrange
  const customer = new Customer();
  const ticket = new Ticket();

  // Act
  customer.purchase(ticket);

  // Assert
  expect(customer).toHaveProperty('ticket');
});
```

## Параметризация тестов (Data-Driven)
Jest позволяет запускать один и тот же тест с разными наборами данных с помощью `test.each`.

```javascript
// test.each(таблица_данных)(имя_теста, функция_теста)

const testCases = [
  [2, 2, 4],
  [1, 5, 6],
  [-1, 1, 0]
];

test.each(testCases)('должен складывать %i и %i и получать %i', (a, b, expected) => {
  expect(a + b).toBe(expected);
});
```

## Работа с ошибками

### Выбрасывание ошибок
В коде ошибки можно создавать и выбрасывать с помощью `throw`.

```javascript
function kolobok(character) {
  if (character === 'лиса') {
    throw new Error('Колобка съели!');
  }
  return 'Колобок жив';
}
```

### Тестирование ошибок
Для проверки того, что функция выбрасывает ошибку, используется матчер `.toThrow()`. Важно передавать в `expect` анонимную функцию, которая вызывает тестируемый код.

```javascript
it('должен выбросить ошибку, если встретил лису', () => {
  // Правильно:
  expect(() => {
    kolobok('лиса');
  }).toThrow('Колобка съели!');

  // Неправильно (код выполнится до передачи в expect):
  // expect(kolobok('лиса')).toThrow('...');
});
```

## Покрытие кода тестами
**Code Coverage** — это метрика, которая показывает, какая часть вашего кода была выполнена во время запуска тестов. Это помогает выявить непротестированные участки кода.

**Основные метрики покрытия:**
- **Function coverage**: Каждая функция была вызвана?
- **Statement coverage**: Каждое выражение было выполнено?
- **Branch coverage**: Каждая ветка условного оператора (if/else) была выполнена?
- **Condition coverage**: Каждое булево подвыражение было оценено как true и false?

## Установка и настройка Jest

1.  **Установка зависимостей:**
    ```bash
    npm install --save-dev jest @types/jest eslint-plugin-jest
    ```

2.  **Создание конфигурационного файла:**
    Запустите помощник по настройке Jest.
    ```bash
    npx jest --init
    # или
    npm init jest@latest
    ```
    Он задаст несколько вопросов (о среде выполнения, необходимости отчетов о покрытии и т.д.) и создаст файл `jest.config.js`.

3.  **Добавление скрипта в `package.json`:**
    ```json
    {
      "scripts": {
        "test": "jest"
      }
    }
    ```

## Полезные ресурсы
- **Официальная документация Jest**: [Getting Started](https://jestjs.io/docs/getting-started)
- **Фиктивные объекты (моки, стабы)**: [Статья на Дока.guide](https://doka.guide/js/fake-objects/)