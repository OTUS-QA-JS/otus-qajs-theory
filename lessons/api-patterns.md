# Шаблоны проектирования в тестировании API


---
Полезные ссылки:
* [Barrel files in JavaScript](https://flaming.codes/posts/barrel-files-in-javascript/) -- это файлы, которые служат точкой входа для группового экспорта модулей из определенной директории. 

---
### Шаблоны проектирования
- это повторяющиеся решения типовых задач

Они помогают:
*	структурировать код,
*	сделать его переиспользуемым,
*	минимизировать дублирование.

В отличие от готовых функций или библиотек, паттерн нельзя просто
взять и скопировать в программу. Паттерн представляет собой не
какой-то конкретный код, а общую концепцию решения той или иной
проблемы, которую нужно будет ещё подстроить под нужды вашей
программы

Типы паттернов
* Поведенческие
* Порождающие
* Структурные

---

### Поведенческие
решают задачи эффективного и
безопасного взаимодействия между
объектами программы.

*  Контроллер - позволяет уменьшить
связанность множества
классов между собой,
благодаря перемещению
этих связей в один класс-
посредник 

Пример из наших тестов: это UserService.js 
По сути мы выносим взаимодействие с api во внешние файлы

Создаём UserService – он как официант, который берёт запросы
тестов и сам отправляет их в API
```
import config from '../../framework/config/configBookstore'
import { AuthService } from '../../framework'
describe('Авторизация', () => {
  it('Успешная авторизация', async () => {
    const response = await AuthService.generateToken({
      userName: config.username,
      password: config.password,
    })
    expect(response.status).toBe(200)
  })
  
  it('Нельзя авторизоваться без пароля', async () => {
    const response = await AuthService.generateToken({
      userName: config.username,
      password: '',
    })
    expect(response.status).toBe(400)
  })
})
```
*  Цепочка обязанностей - позволяет передавать
   запросы последовательно по
   цепочке обработчиков.
   Каждый последующий
   обработчик решает, может ли
   он обработать запрос сам и
   стоит ли передавать запрос
   дальше по цепи
   
В framework/services/UserBookService.js реализован данный паттерн
   Supertest сам по себе этот паттерн и реализует
   У нас есть supertest: supertest(config.baseURL)
```
const replaceBook = async ({ userId, fromIsbn, toIsbn, token }) => {
  const response = await supertest(config.baseURL)
   .put(/BookStore/v1/Books/${fromIsbn})
   .set(‘Authorization’, Bearer ${token})
 }
```
В этом коде используется подход, похожий на цепочку обязанностей,
потому что каждый метод в supertest выполняет свою часть работы и
передает результат дальше, пока запрос полностью не выполнится
---
### Порождающие
отвечат за удобное и безопасное
создание новых объектов или даже
целых семейств объектов
* Строитель - позволяет создавать
  сложные объекты
  пошагово. Даёт
  возможность использовать
  один и тот же код
  строительства для
  получения разных
  представлений объектов

В контексте тестов его можно отнести к параметризированным тестам

Рассмотрим на примере паттерн Строитель: 
Тестовые данные собираются в виде массива объектов
(testCasesNegative), а затем передаются в тест через test.each()
```
const testCasesNegative = [
  {
   // …
  },
  {
   // …
  },
 ]

 test.each(testCasesNegative)(
  ‘%s’,
  ({ products, discount, expectedError }) => {
   expect(() => calculateTotal(products, discount)).toThrow(expectedError)
  },
 )
```
---
### Структурные 
отвечают за построение
удобного в поддержке кода
* Декоратор - позволяет динамически
  добавлять объектам новую
  функциональность,
  оборачивая их в полезные
  «обёртки»


  В качестве примера в сервисах в UserBookService создадим
  декоратор, который кеширует результат первого запроса и отдаёт его
  при повторных вызовах
```
 async function fetchProducts(): Promise {
  const response = await supertest(config.baseURL).get(’/products’)
  return response.body
 }
```
Теперь создадим Декоратор с кешированием:

```
function cacheDecorator(fn) {
  let cache = null
  return async function (): Promise<…> {
   if (cache) return cache   // Если уже есть кеш, возвращаем его
   cache = await fn()      // Иначе вызываем оригинальную функцию и сохраняем результат
   return cache
  }
 }

 const fetchProductsCached = cacheDecorator(fetchProducts)
```
Теперь, если мы вызываем fetchProductsCached(), первый раз он сделает
реальный запрос, а в последующие вызовы будет отдавать кешированный
результат

* Фасад - предоставляет простой
  интерфейс к сложной
  системе классов, библиотеке
  или фреймворку


  Можно сравнить fetch и axios

В fetch: указываем метод, пробрасываем заголовки, превращаем в джейсон строку тело нашего запроса
В axios всего этого делать не нужно, он под коробкой: превращает объект в json строку, подставляет заголовок: content - json

* Адаптер - позволяет объектам с
  несовместимыми интерфейсами
  работать вместе

Примеры из разных библиотек, которые по разному возвращают
данные

1 - supertest в BookService.js

2 - fetch в AuthService.js

3 - axios в UserService.js

```
 const generateToken = async ({ userName, password }) => {
  const response = await fetch(// …
  // …
  return {
   headers: response.headers,
   status: response.status,
   data: await response.json(),
  }
 }

 const getBooks = async () => {
  const response = await supertest(// …
  return {
   headers: response.headers,
   status: response.status,
   data: response.body,
  }
 }
```

* Компоновщик - позволяет сгруппировать
  множество объектов в
  древовидную структуру, а
  затем работать с ней так, как
  будто это единичный объект

Примером компоновщика в тестах можно назвать ре-ре-экспорт

Мы в одном месте объединяем контроллеры, фикстуры, конфиги в один большой
объект и потом импортируем из одного фреймворка сервисы, конфиги, фикстуры

Теперь можно импортировать всё одной строкой
```
import { AuthService, UserService, UserFixture } from '../../framework'
```
Вместо множества отдельных импортов
```
../../framework/services/authService,
../../framework/fixtures/userFixture)
```
Мы импортируем всё сразу из одного места.

---
### Структура проекта
```
project-root/
├── config/
│   └── config.js
├── fixtures/
│   └── testData.js
├── services/
│   ├── AuthService.js
│   ├── BookService.js
│   └── UserService.js
├── tests/
│   └── auth.test.js
└── framework/
└── index.js
```
---
### Re-exports
```
// framework/index.js
export * as config from './config'
export * from './services'
export * from './fixtures

// tests/bookstore/users.test.js
import { AuthService, UserService, UserFixture } from '../../framework'
```

---
### Примерный план разработки тестового покрытия
#### Шаг 1 - проверять только статусы
*  Быстрое покрытие тестами
Проверки HTTP-статусов (200, 400, 401, 500) легко добавить и они сразу
дадут базовую уверенность, что API отвечает.
*  Не тратите время на сложные проверки в начале
Если детально проверять каждый ответ (data, headers, структуру JSON), на
написание тестов уйдёт больше времени.
На старте важнее быстро покрыть API и убедиться, что оно вообще работает.
Примерный план разработки тестового покрытия.
*  Минимум false-positive ошибок
Если API слегка меняет формат данных, тесты на структуру ответа могут
падать, даже если бизнес-логика не сломалась.
Проверка только статусов устойчива к таким изменениям.
Примерный план разработки тестового покрытия.
*  Без них приложение точно не будет работать
Авторизация, регистрация, обработка платежей — это ключевые
фичи, без которых всё остальное не имеет смысла.
Если, например, логин не работает, то API вообще нельзя
полноценно тестировать.
Примерный план разработки тестового покрытия.
*  Больше пользы от тестов
Вместо написания сотен мелких тестов на неважные детали, лучше
покрыть основные сценарии, которые реально критичны.
*  Позволяет гибко расширять тесты
Сначала просто статусы, потом критичные места,
Затем уже можно детально проверять данные в ответе, логику API,
бизнес-правила.

#### Подход разработки тестового покрытия. Итог:
На старте — быстро проверяем статусы, чтобы увидеть общую
картину работоспособности API.
* После этого — тестируем самые важные и критичные функции.
* Дальше — углубляем проверки на данные, логику и сложные
сценарии.
Этот подход экономит время, даёт быстрый результат и позволяет
постепенно улучшать покрытие, а не застрять на сложных проверках
в начале
