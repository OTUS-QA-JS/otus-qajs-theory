# Паттерны проектирования в тестировании API

## Содержание
- [Что такое паттерн проектирования?](#что-такое-паттерн-проектирования)
- [Поведенческие паттерны](#поведенческие-паттерны)
- [Порождающие паттерны](#порождающие-паттерны)
- [Структурные паттерны](#структурные-паттерны)
- [Стратегия разработки тестового покрытия](#стратегия-разработки-тестового-покрытия)
- [Полезные ресурсы](#полезные-ресурсы)

## Что такое паттерн проектирования?

**Шаблон проектирования (паттерн)** — это повторяемое, универсальное решение часто возникающей проблемы в рамках проектирования программного обеспечения. Это не готовый код или библиотека, а общая концепция или подход, который нужно адаптировать под конкретные нужды проекта.

В отличие от **алгоритма**, который представляет собой четкий набор шагов, **паттерн** — это высокоуровневое описание решения, реализация которого может отличаться в разных программах. Паттерны помогают структурировать код, делать его переиспользуемым и минимизировать дублирование.

Паттерны делятся на три основные группы: поведенческие, порождающие и структурные.

## Поведенческие паттерны

Решают задачи эффективного и безопасного взаимодействия между объектами в программе.

### Контроллер (Controller / Mediator)

**Идея**: Уменьшает связанность множества объектов, перемещая логику взаимодействия в один класс-посредник.

**Применение в тестах**: Слой сервисов (например, `AuthService.js`, `UserService.js`) выступает в роли контроллера. Тесты вызывают методы сервиса, а не отправляют HTTP-запросы напрямую. Это скрывает детали реализации API и делает тесты более чистыми и устойчивыми к изменениям в эндпоинтах.

```javascript
// В тесте мы не работаем с fetch/axios напрямую
import { AuthService } from '../../framework';

it('Успешная авторизация', async () => {
  // Тест вызывает метод сервиса (контроллера)
  const response = await AuthService.generateToken({
    userName: config.username,
    password: config.password,
  });
  expect(response.status).toBe(200);
});
```

### Цепочка обязанностей (Chain of Responsibility)

**Идея**: Позволяет передавать запрос последовательно по цепочке обработчиков. Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать его дальше.

**Применение в тестах**: Библиотеки для HTTP-запросов, такие как `supertest`, используют этот паттерн. Каждый вызов метода (`.post()`, `.set()`, `.send()`) добавляет к запросу новую часть и передает его дальше по цепочке до момента отправки.

```javascript
const response = await supertest(config.baseURL) // 1. Начало цепочки
  .put(`/BookStore/v1/Books/${isbn}`)         // 2. Установка эндпоинта и метода
  .set('Authorization', `Bearer ${token}`)   // 3. Добавление заголовка
  .send({ newBook: '...' });                  // 4. Добавление тела и отправка
```

## Порождающие паттерны

Отвечают за удобное и безопасное создание новых объектов.

### Строитель (Builder)

**Идея**: Позволяет создавать сложные объекты пошагово. Один и тот же процесс конструирования может создавать разные представления объекта.

**Применение в тестах**: Паттерн можно соотнести с параметризованными тестами (`test.each`). Здесь "строителем" выступает сам Jest, который пошагово "собирает" и запускает тест для каждого набора данных.

```javascript
// 1. Определяем "чертежи" для сборки - наборы данных
const testCases = [
  { products: [10, 20], discount: 0, expected: 30 },
  { products: [10, 20], discount: 5, expected: 25 },
];

// 2. Jest (`test.each`) выступает как "строитель",
// создавая тест для каждого "чертежа"
test.each(testCases)('должен правильно считать сумму для %#', ({ products, discount, expected }) => {
  const result = calculateTotal(products, discount);
  expect(result).toBe(expected);
});
```

## Структурные паттерны

Отвечают за построение удобных в поддержке иерархий классов и объектов.

### Декоратор (Decorator / Wrapper)

**Идея**: Позволяет динамически добавлять объектам новую функциональность, оборачивая их в "обертки".

**Применение в тестах**: Часто используется для кеширования. Можно создать функцию-декоратор, которая будет кешировать ответы от API. При первом вызове она выполнит реальный запрос, а при последующих — вернет сохраненный результат. Это ускоряет выполнение тестов и снижает нагрузку на API.

```javascript
// Функция-декоратор для кеширования
function cacheDecorator(fn) {
  let cache = null;
  return async function(...args) {
    if (cache) return cache; // Если есть кеш, возвращаем его
    cache = await fn(...args); // Иначе вызываем функцию и сохраняем результат
    return cache;
  };
}

// Оригинальная функция для запроса
async function fetchProducts() {
  const response = await supertest(config.baseURL).get('/products');
  return response.body;
}

// Применение декоратора
const fetchProductsCached = cacheDecorator(fetchProducts);

// В тестах используется кешированная версия
await fetchProductsCached(); // Первый вызов сделает запрос к API
await fetchProductsCached(); // Второй вызов вернет результат из кеша
```

### Фасад (Facade)

**Идея**: Предоставляет простой интерфейс к сложной системе, скрывая ее внутреннюю реализацию.

**Применение в тестах**: Библиотеки `axios` и `supertest` являются фасадом над нативным `fetch` или модулем `node:http`. Они предоставляют удобные методы (`.get()`, `.post()`) и автоматически выполняют рутинные операции, такие как сериализация тела запроса в JSON и установка заголовка `Content-Type`.

### Адаптер (Adapter)

**Идея**: Позволяет объектам с несовместимыми интерфейсами работать вместе.

**Применение в тестах**: При использовании разных HTTP-клиентов (`fetch`, `axios`, `supertest`) каждый из них возвращает ответ в своем формате (`response.json()`, `response.data`, `response.body`). Слой сервисов может выступать в роли адаптера, приводя все ответы к единой структуре, например `{ status, data, headers }`. Это делает код тестов независимым от используемой библиотеки.

```javascript
// Адаптер для supertest
async function getBooks() {
  const response = await supertest(...);
  return {
    status: response.status,
    data: response.body, // supertest использует .body
  };
}

// Адаптер для fetch
async function generateToken() {
  const response = await fetch(...);
  return {
    status: response.status,
    data: await response.json(), // fetch требует вызова .json()
  };
}
```

### Компоновщик (Composite)

**Идея**: Позволяет сгруппировать множество объектов в древовидную структуру и работать с ней как с единым объектом.

**Применение в тестах**: Использование "barrel files" (`index.js`) для ре-экспорта модулей. Вместо множества импортов из разных файлов, мы создаем единую точку входа, которая объединяет все сервисы, фикстуры и конфиги. Это упрощает импорты в тестах и скрывает внутреннюю структуру проекта.

```javascript
// framework/services/index.js
export { default as AuthService } from './AuthService';
export { default as BookService } from './BookService';

// framework/index.js
export * from './services';
export * as fixtures from './fixtures';

// В файле теста
// Импортируем все необходимое одной строкой из "компоновщика"
import { AuthService, BookService, fixtures } from '../../framework';
```

## Стратегия разработки тестового покрытия

Эффективный подход к написанию API-тестов — двигаться от общего к частному.

### Шаг 1: Проверка статусов
Начните с самых простых тестов — проверки кодов ответа HTTP (200, 400, 401 и т.д.).
- **Преимущества**: Дает быстрое и широкое покрытие, проверяя, что эндпоинты в принципе доступны и отвечают. Такие тесты устойчивы к небольшим изменениям в теле ответа.

### Шаг 2: Тестирование критичных сценариев
Сосредоточьтесь на ключевой бизнес-логике: авторизация, регистрация, создание заказа, проведение оплаты. Если эти сценарии не работают, остальные тесты теряют смысл.

### Шаг 3: Углубленные проверки
После того как базовые проверки и критичные пути покрыты, добавляйте детальные ассерты:
- Проверка структуры тела ответа.
- Проверка конкретных значений в полях.
- Проверка заголовков ответа.
- Тестирование сложных бизнес-правил и пограничных случаев.

Такой подход позволяет быстро получить ценность от тестов и постепенно наращивать их сложность и глубину, не застревая на деталях в самом начале.

## Полезные ресурсы
- **Barrel files in JavaScript**: [Статья о паттерне "Компоновщик" для импортов](https://flaming.codes/posts/barrel-files-in-javascript/)